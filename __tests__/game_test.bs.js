// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Game from "../src/Game.bs.js";
import * as Jest from "@glennsl/bs-jest/src/jest.bs.js";
import * as $$Array from "bs-platform/lib/es6/array.js";
import * as Board from "../src/Board.bs.js";
import * as React from "react";
import * as Enzyme from "bs-enzyme/src/Enzyme.bs.js";
import * as Enzyme$1 from "enzyme";
import EnzymeAdapterReact from "@wojtekmaj/enzyme-adapter-react-17";

Enzyme.configureEnzyme(new EnzymeAdapterReact());

function matrixToCells(matrix) {
  return Board.sortCells($$Array.to_list($$Array.fold_left($$Array.append, [], $$Array.mapi((function (y, row) {
                            return $$Array.mapi((function (x, color) {
                                          return {
                                                  x: x,
                                                  y: y,
                                                  color: color
                                                };
                                        }), row);
                          }), matrix))));
}

var w = /* White */0;

var b = /* Black */1;

var fakeGame = Game.init([
      {
        name: "foo",
        color: /* Black */1
      },
      {
        name: "bar",
        color: /* White */0
      }
    ]);

Jest.describe("Game", (function (param) {
        Jest.describe("currentPlayer", (function (param) {
                return Jest.test("should return current player for game", (function (param) {
                              return Jest.Expect.toEqual({
                                          name: "foo",
                                          color: /* Black */1
                                        }, Jest.Expect.expect(Game.currentPlayer(fakeGame)));
                            }));
              }));
        Jest.describe("playerCanPlay", (function (param) {
                Jest.test("should return true if player can place cell change", (function (param) {
                        return Jest.Expect.toBe(true, Jest.Expect.expect(Game.playerCanPlay(fakeGame, 0)));
                      }));
                return Jest.test("should return false if player can't place cell change", (function (param) {
                              return Jest.Expect.toBe(false, Jest.Expect.expect(Game.playerCanPlay({
                                                  board: Board.init(2, 2),
                                                  players: fakeGame.players,
                                                  playerIndex: fakeGame.playerIndex,
                                                  finished: fakeGame.finished
                                                }, 0)));
                            }));
              }));
        Jest.describe("switchPlayer", (function (param) {
                Jest.test("should return a switched game if player can play", (function (param) {
                        var originPlayerIndex = fakeGame.playerIndex;
                        return Jest.Expect.toBe(originPlayerIndex, Jest.Expect.not__(Jest.Expect.expect(Game.switchPlayer(fakeGame).playerIndex)));
                      }));
                Jest.test("should raise CantSwitchPlayer if player can't be switched", (function (param) {
                        var gameWithoutMove_board = {
                          width: 4,
                          height: 4,
                          cells: matrixToCells([
                                [
                                  b,
                                  w,
                                  undefined,
                                  undefined
                                ],
                                [
                                  undefined,
                                  w,
                                  undefined,
                                  undefined
                                ],
                                [
                                  undefined,
                                  undefined,
                                  undefined,
                                  undefined
                                ],
                                [
                                  undefined,
                                  undefined,
                                  undefined,
                                  undefined
                                ]
                              ])
                        };
                        var gameWithoutMove_players = fakeGame.players;
                        var gameWithoutMove_playerIndex = fakeGame.playerIndex;
                        var gameWithoutMove_finished = fakeGame.finished;
                        var gameWithoutMove = {
                          board: gameWithoutMove_board,
                          players: gameWithoutMove_players,
                          playerIndex: gameWithoutMove_playerIndex,
                          finished: gameWithoutMove_finished
                        };
                        return Jest.Expect.toThrow(Jest.Expect.expect(function (param) {
                                        return Game.switchPlayer(gameWithoutMove);
                                      }));
                      }));
                return Jest.test("should raise InsolubleGame with finished game if there's no possible cell change", (function (param) {
                              var gameWithoutSolution_board = Board.init(2, 2);
                              var gameWithoutSolution_players = fakeGame.players;
                              var gameWithoutSolution_playerIndex = fakeGame.playerIndex;
                              var gameWithoutSolution_finished = fakeGame.finished;
                              var gameWithoutSolution = {
                                board: gameWithoutSolution_board,
                                players: gameWithoutSolution_players,
                                playerIndex: gameWithoutSolution_playerIndex,
                                finished: gameWithoutSolution_finished
                              };
                              return Jest.Expect.toThrow(Jest.Expect.expect(function (param) {
                                              return Game.switchPlayer(gameWithoutSolution);
                                            }));
                            }));
              }));
        Jest.describe("applyCellClick", (function (param) {
                Jest.test("should return finished game if last cell change", (function (param) {
                        var init = Board.init(3, 3);
                        var game_board = {
                          width: init.width,
                          height: init.height,
                          cells: matrixToCells([
                                [
                                  w,
                                  w,
                                  w
                                ],
                                [
                                  undefined,
                                  w,
                                  b
                                ],
                                [
                                  w,
                                  w,
                                  w
                                ]
                              ])
                        };
                        var game_players = fakeGame.players;
                        var game_playerIndex = fakeGame.playerIndex;
                        var game_finished = fakeGame.finished;
                        var game = {
                          board: game_board,
                          players: game_players,
                          playerIndex: game_playerIndex,
                          finished: game_finished
                        };
                        return Jest.Expect.toEqual({
                                    board: game_board,
                                    players: game_players,
                                    playerIndex: game_playerIndex,
                                    finished: true
                                  }, Jest.Expect.expect(Game.applyCellClick(game, 0, 1)));
                      }));
                return Jest.test("should return game with switched player instead", (function (param) {
                              var init = Board.init(4, 4);
                              var game_board = {
                                width: init.width,
                                height: init.height,
                                cells: matrixToCells([
                                      [
                                        undefined,
                                        undefined,
                                        undefined,
                                        undefined
                                      ],
                                      [
                                        undefined,
                                        b,
                                        w,
                                        undefined
                                      ],
                                      [
                                        undefined,
                                        w,
                                        b,
                                        undefined
                                      ],
                                      [
                                        undefined,
                                        undefined,
                                        undefined,
                                        undefined
                                      ]
                                    ])
                              };
                              var game_players = fakeGame.players;
                              var game_playerIndex = fakeGame.playerIndex;
                              var game_finished = fakeGame.finished;
                              var game = {
                                board: game_board,
                                players: game_players,
                                playerIndex: game_playerIndex,
                                finished: game_finished
                              };
                              return Jest.Expect.toEqual(1, Jest.Expect.expect(Game.applyCellClick(game, 1, 3).playerIndex));
                            }));
              }));
        return Jest.describe("<Game />", (function (param) {
                      Jest.test("should render a <Board />", (function (param) {
                              var wrapper = Enzyme$1.shallow(React.createElement(Game.make, {
                                        game: fakeGame
                                      }));
                              return Jest.Expect.toBe(1, Jest.Expect.expect(wrapper.find("Board").length));
                            }));
                      Jest.test("should render <Player(s) />", (function (param) {
                              var wrapper = Enzyme$1.shallow(React.createElement(Game.make, {
                                        game: fakeGame
                                      }));
                              return Jest.Expect.toBe(2, Jest.Expect.expect(wrapper.find("Player").length));
                            }));
                      return Jest.test("should render 'finished' block if game is finished", (function (param) {
                                    var wrapper = Enzyme$1.shallow(React.createElement(Game.make, {
                                              game: {
                                                board: fakeGame.board,
                                                players: fakeGame.players,
                                                playerIndex: fakeGame.playerIndex,
                                                finished: true
                                              }
                                            }));
                                    return Jest.Expect.toBe(1, Jest.Expect.expect(wrapper.find(".finished").length));
                                  }));
                    }));
      }));

var n;

export {
  matrixToCells ,
  w ,
  b ,
  n ,
  fakeGame ,
  
}
/*  Not a pure module */
