// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Cell from "./Cell.bs.js";
import * as List from "bs-platform/lib/es6/list.js";
import * as $$Array from "bs-platform/lib/es6/array.js";
import * as Curry from "bs-platform/lib/es6/curry.js";
import * as React from "react";
import * as Caml_obj from "bs-platform/lib/es6/caml_obj.js";
import * as Belt_List from "bs-platform/lib/es6/belt_List.js";
import * as Caml_int32 from "bs-platform/lib/es6/caml_int32.js";
import * as Caml_exceptions from "bs-platform/lib/es6/caml_exceptions.js";
import * as Caml_js_exceptions from "bs-platform/lib/es6/caml_js_exceptions.js";

var InvalidMove = /* @__PURE__ */Caml_exceptions.create("Board.InvalidMove");

function sortCells(param) {
  return List.sort((function (c1, c2) {
                return (Math.imul(c1.y, 10) + c1.x | 0) - (Math.imul(c2.y, 10) + c2.x | 0) | 0;
              }), param);
}

function initCells(width, height, color) {
  return Belt_List.makeBy(Math.imul(width, height), (function (i) {
                return {
                        x: Caml_int32.mod_(i, width),
                        y: Caml_int32.div(i, width),
                        color: color
                      };
              }));
}

function drawCells(cells, cellsToDraw) {
  return sortCells(List.append(cellsToDraw, List.filter(function (cell) {
                        return !List.exists((function (param) {
                                      if (param.x === cell.x) {
                                        return param.y === cell.y;
                                      } else {
                                        return false;
                                      }
                                    }), cellsToDraw);
                      })(cells)));
}

function getCell(x, y, cells) {
  var val;
  try {
    val = List.find((function (cell) {
            if (cell.x === x) {
              return cell.y === y;
            } else {
              return false;
            }
          }), cells);
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.RE_EXN_ID === "Not_found") {
      return ;
    }
    throw exn;
  }
  return val.color;
}

function init(width, height) {
  var mw = width / 2 | 0;
  var mh = height / 2 | 0;
  var cells = drawCells(initCells(width, height, undefined), {
        hd: {
          x: mw,
          y: mh,
          color: /* Black */1
        },
        tl: {
          hd: {
            x: mw - 1 | 0,
            y: mh - 1 | 0,
            color: /* Black */1
          },
          tl: {
            hd: {
              x: mw - 1 | 0,
              y: mh,
              color: /* White */0
            },
            tl: {
              hd: {
                x: mw,
                y: mh - 1 | 0,
                color: /* White */0
              },
              tl: /* [] */0
            }
          }
        }
      });
  return {
          width: width,
          height: height,
          cells: cells
        };
}

function getCountForColor(board, color) {
  return List.length(List.filter(function (c) {
                    return Caml_obj.caml_equal(c.color, color);
                  })(board.cells));
}

var directions = {
  hd: [
    0,
    1
  ],
  tl: {
    hd: [
      0,
      -1
    ],
    tl: {
      hd: [
        1,
        0
      ],
      tl: {
        hd: [
          1,
          1
        ],
        tl: {
          hd: [
            1,
            -1
          ],
          tl: {
            hd: [
              -1,
              0
            ],
            tl: {
              hd: [
                -1,
                1
              ],
              tl: {
                hd: [
                  -1,
                  -1
                ],
                tl: /* [] */0
              }
            }
          }
        }
      }
    }
  }
};

function isOutOfBound(param, param$1) {
  var y = param$1[1];
  var x = param$1[0];
  if (x < 0 || y < 0 || x > (param.width - 1 | 0)) {
    return true;
  } else {
    return y > (param.height - 1 | 0);
  }
}

function flippedCellsInDirection(board, cell, param) {
  var diry = param[1];
  var dirx = param[0];
  var cells = /* [] */0;
  var cursor = [
    cell.x + dirx | 0,
    cell.y + diry | 0
  ];
  var $$break = false;
  while(!$$break) {
    var cursor$1 = cursor;
    var y = cursor$1[1];
    var x = cursor$1[0];
    var tmp;
    if (isOutOfBound(board, cursor$1)) {
      $$break = true;
      tmp = /* [] */0;
    } else {
      var color = getCell(x, y, board.cells);
      if (color !== undefined) {
        if (Caml_obj.caml_equal(color, cell.color)) {
          $$break = true;
          tmp = cells;
        } else {
          cursor = [
            x + dirx | 0,
            y + diry | 0
          ];
          tmp = {
            hd: {
              x: x,
              y: y,
              color: cell.color
            },
            tl: cells
          };
        }
      } else {
        $$break = true;
        tmp = /* [] */0;
      }
    }
    cells = tmp;
  };
  return cells;
}

function getFlippedCells(board, cell) {
  var flipped = List.flatten(List.map((function (param) {
              return flippedCellsInDirection(board, cell, param);
            }), directions));
  if (flipped) {
    return {
            hd: cell,
            tl: flipped
          };
  } else {
    return /* [] */0;
  }
}

function availableCellChanges(board, color) {
  return List.filter(function (cell) {
                var match = getFlippedCells(board, cell);
                if (match) {
                  return true;
                } else {
                  return false;
                }
              })(initCells(board.width, board.height, color));
}

function applyCellChange(board, cell) {
  var match = getCell(cell.x, cell.y, board.cells);
  if (match !== undefined) {
    throw {
          RE_EXN_ID: InvalidMove,
          Error: new Error()
        };
  }
  var flipped = getFlippedCells(board, cell);
  var cells;
  if (flipped) {
    cells = drawCells(board.cells, flipped);
  } else {
    throw {
          RE_EXN_ID: InvalidMove,
          Error: new Error()
        };
  }
  return {
          width: board.width,
          height: board.height,
          cells: cells
        };
}

function Board(Props) {
  var board = Props.board;
  var onCellClick = Props.onCellClick;
  var cellWidth = (100 / board.width).toString() + "%";
  var cells = $$Array.map((function (cell) {
          return React.createElement("div", {
                      key: String(cell.y) + String(cell.x),
                      style: {
                        width: cellWidth
                      }
                    }, React.createElement(Cell.make, {
                          color: cell.color,
                          onClick: (function (param) {
                              return Curry._1(onCellClick, cell);
                            })
                        }));
        }), $$Array.of_list(board.cells));
  return React.createElement("div", {
              className: "board"
            }, cells);
}

var make = Board;

export {
  InvalidMove ,
  sortCells ,
  initCells ,
  drawCells ,
  getCell ,
  init ,
  getCountForColor ,
  directions ,
  isOutOfBound ,
  flippedCellsInDirection ,
  getFlippedCells ,
  availableCellChanges ,
  applyCellChange ,
  make ,
  
}
/* Cell Not a pure module */
